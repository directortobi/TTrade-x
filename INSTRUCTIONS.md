-- =================================================================
-- TRADE X: FULL SUPABASE DATABASE & STORAGE SETUP SCRIPT
-- =================================================================
-- This script is idempotent, meaning it is safe to run multiple times.
-- It will set up user profiles, token management, storage for
-- payment proofs, and all other necessary database structures.
-- =================================================================


-- ========= USERS & PROFILES =========
-- 1. Create the profiles table with referral fields
CREATE TABLE public.profiles (
  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE,
  email text,
  tokens integer DEFAULT 12 NOT NULL,
  referral_code text UNIQUE,
  referred_by text,
  updated_at timestamp WITH TIME ZONE,
  PRIMARY KEY (id),
  CONSTRAINT email_length CHECK (char_length(email) >= 3 AND char_length(email) <= 255)
);

-- 2. Enable Row Level Security
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- 3. Create RLS policies for profiles
CREATE POLICY "Public profiles are viewable by everyone." ON profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update own profile." ON profiles FOR UPDATE USING (auth.uid() = id);

-- 4. Create a function to generate a unique referral code
CREATE OR REPLACE FUNCTION public.generate_referral_code()
RETURNS text LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  new_code text;
  is_duplicate boolean;
BEGIN
  LOOP
    new_code := upper(substr(md5(random()::text), 0, 9)); -- 8-char random code
    SELECT EXISTS(SELECT 1 FROM public.profiles WHERE referral_code = new_code) INTO is_duplicate;
    IF NOT is_duplicate THEN
      RETURN new_code;
    END IF;
  END LOOP;
END;
$$;

-- 5. Create a trigger function to handle new user sign-ups
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  -- Check if the new user was referred
  -- This part is a placeholder; referral link logic is handled client-side on signup
  -- and the 'referred_by' field is set there.
  INSERT INTO public.profiles (id, email, referral_code)
  VALUES (new.id, new.email, public.generate_referral_code());
  RETURN new;
END;
$$;

-- 6. Create the trigger that calls the function
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- 7. Function to decrement user tokens transactionally
CREATE OR REPLACE FUNCTION public.decrement_user_tokens(p_user_id uuid, p_amount integer)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER AS $$
DECLARE
  v_current_tokens integer;
  v_new_tokens integer;
BEGIN
  -- Select and lock the user's profile row to prevent race conditions
  SELECT tokens INTO v_current_tokens FROM public.profiles WHERE id = p_user_id FOR UPDATE;

  IF v_current_tokens IS NULL THEN
    RAISE EXCEPTION 'User profile not found';
  END IF;

  IF v_current_tokens < p_amount THEN
    RAISE EXCEPTION 'Insufficient tokens for analysis';
  END IF;

  v_new_tokens := v_current_tokens - p_amount;

  UPDATE public.profiles
  SET tokens = v_new_tokens
  WHERE id = p_user_id;

  RETURN v_new_tokens;
END;
$$;


-- ========= ANALYSIS & STRATEGIES =========
-- 8. Create AnalysisLog table
CREATE TABLE public.analysis_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    user_email TEXT NOT NULL,
    symbol TEXT,
    signal TEXT,
    entry_price NUMERIC,
    stop_loss NUMERIC,
    take_profit_1 NUMERIC,
    confidence NUMERIC,
    analysis_notes TEXT,
    outcome TEXT DEFAULT 'Pending'::text,
    tokens_used INT DEFAULT 1
);
ALTER TABLE public.analysis_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own analysis logs" ON public.analysis_logs
    FOR ALL USING (auth.email() = user_email);

-- 9. Create TradingStrategy table
CREATE TABLE public.trading_strategies (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    user_id UUID DEFAULT auth.uid() NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    symbol TEXT,
    timeframe TEXT,
    is_active BOOLEAN DEFAULT false
);
ALTER TABLE public.trading_strategies ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own strategies" ON public.trading_strategies
    FOR ALL USING (auth.uid() = user_id);

-- ========= PAYMENTS & TOKENS =========
-- 10. Create the token_purchases table
CREATE TABLE public.token_purchases (
    id UUID DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users ON DELETE CASCADE,
    package_name TEXT NOT NULL,
    tokens_purchased INTEGER NOT NULL,
    price_usd NUMERIC NOT NULL,
    payment_proof_url TEXT,
    status TEXT DEFAULT 'pending'::text NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL
);
ALTER TABLE public.token_purchases ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own token purchases." ON public.token_purchases
    FOR ALL USING (auth.uid() = user_id);
-- Admins can be given access via service_role key on the backend

-- 11. Create a bucket for payment proofs
-- IMPORTANT: This step is critical for the "Buy Tokens" feature.
-- It creates the storage location for user-uploaded payment receipts.
-- If this fails, users will see a "Bucket not found" error.
INSERT INTO storage.buckets (id, name, public)
VALUES ('payment_proofs', 'payment_proofs', true)
ON CONFLICT (id) DO NOTHING;

-- 12. Create storage policies for payment_proofs bucket
CREATE POLICY "Authenticated users can upload payment proofs"
ON storage.objects FOR INSERT TO authenticated
WITH CHECK ( bucket_id = 'payment_proofs' AND (storage.foldername(name))[1] = auth.uid()::text );

CREATE POLICY "Users can view their own payment proofs"
ON storage.objects FOR SELECT TO authenticated
USING ( bucket_id = 'payment_proofs' AND (storage.foldername(name))[1] = auth.uid()::text );

CREATE POLICY "Admins can view all payment proofs"
ON storage.objects FOR SELECT USING (true); -- In production, use a role check

-- ========= WITHDRAWALS =========
-- 13. Create the withdrawals table (FOR TOKENS)
CREATE TABLE public.withdrawals (
    id UUID DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users ON DELETE CASCADE,
    tokens_to_withdraw INTEGER NOT NULL,
    wallet_address TEXT NOT NULL,
    status TEXT DEFAULT 'pending'::text NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL
);
ALTER TABLE public.withdrawals ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own withdrawal requests." ON public.withdrawals
    FOR ALL USING (auth.uid() = user_id);

-- 14. Create the database function for TOKEN withdrawal approval transaction
CREATE OR REPLACE FUNCTION approve_withdrawal_transaction(p_withdrawal_id uuid)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  v_user_id uuid;
  v_tokens_to_withdraw int;
  v_current_tokens int;
BEGIN
  -- Get withdrawal details and lock the row for update
  SELECT user_id, tokens_to_withdraw
  INTO v_user_id, v_tokens_to_withdraw
  FROM public.withdrawals
  WHERE id = p_withdrawal_id AND status = 'pending'
  FOR UPDATE;

  IF NOT FOUND THEN RAISE EXCEPTION 'Withdrawal not found or not pending'; END IF;

  -- Get user's current token balance and lock the row
  SELECT tokens INTO v_current_tokens FROM public.profiles WHERE id = v_user_id FOR UPDATE;
  IF v_current_tokens IS NULL THEN RAISE EXCEPTION 'User profile not found'; END IF;

  -- Check for sufficient funds
  IF v_current_tokens < v_tokens_to_withdraw THEN RAISE EXCEPTION 'Insufficient funds'; END IF;

  -- Debit tokens from user's profile
  UPDATE public.profiles SET tokens = tokens - v_tokens_to_withdraw WHERE id = v_user_id;

  -- Update withdrawal status to 'approved'
  UPDATE public.withdrawals SET status = 'approved' WHERE id = p_withdrawal_id;
END;
$$;

-- ========= REFERRALS =========
-- 15. Create ReferralEarnings table
CREATE TABLE public.referral_earnings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    referrer_id UUID NOT NULL REFERENCES auth.users(id),
    referred_user_id UUID NOT NULL REFERENCES auth.users(id),
    purchase_id UUID NOT NULL REFERENCES public.token_purchases(id),
    purchase_amount NUMERIC NOT NULL,
    commission_amount NUMERIC NOT NULL,
    status TEXT DEFAULT 'pending'::text,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL
);
ALTER TABLE public.referral_earnings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own earnings." ON public.referral_earnings
    FOR SELECT USING (auth.uid() = referrer_id);

-- 16. NEW: Create Referral Withdrawals table
CREATE TABLE public.referral_withdrawals (
    id UUID DEFAULT gen_random_uuid() NOT NULL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    amount_usd NUMERIC NOT NULL,
    wallet_address TEXT NOT NULL,
    status TEXT DEFAULT 'pending'::text NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now() NOT NULL
);
ALTER TABLE public.referral_withdrawals ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own referral withdrawals"
ON public.referral_withdrawals FOR ALL USING (auth.uid() = user_id);

-- 17. NEW: Secure function to approve a purchase and create commission
CREATE OR REPLACE FUNCTION public.handle_purchase_approval(p_purchase_id uuid)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER AS $$
DECLARE
  v_purchase record;
  v_referrer_id uuid;
  v_buyer_referral_code text;
  v_commission_amount numeric;
BEGIN
  -- 1. Get purchase details and lock the row
  SELECT * INTO v_purchase FROM public.token_purchases WHERE id = p_purchase_id AND status = 'pending' FOR UPDATE;
  IF NOT FOUND THEN RAISE EXCEPTION 'Purchase not found or not pending'; END IF;
  
  -- 2. Credit tokens to the buyer
  UPDATE public.profiles SET tokens = tokens + v_purchase.tokens_purchased WHERE id = v_purchase.user_id;

  -- 3. Update the purchase status to 'approved'
  UPDATE public.token_purchases SET status = 'approved' WHERE id = p_purchase_id;

  -- 4. Check if the buyer was referred
  SELECT referred_by INTO v_buyer_referral_code
  FROM public.profiles
  WHERE id = v_purchase.user_id;
  
  -- 5. If they have a referral code, find the referrer and create the commission
  IF v_buyer_referral_code IS NOT NULL THEN
    -- Find the referrer's ID using the referral code
    SELECT id INTO v_referrer_id FROM public.profiles WHERE referral_code = v_buyer_referral_code;

    IF v_referrer_id IS NOT NULL THEN
      v_commission_amount := v_purchase.price_usd * 0.20; -- 20% commission
      INSERT INTO public.referral_earnings (referrer_id, referred_user_id, purchase_id, purchase_amount, commission_amount, status)
      VALUES (v_referrer_id, v_purchase.user_id, v_purchase.id, v_purchase.price_usd, v_commission_amount, 'pending');
      
      -- ADD NOTIFICATION FOR REFERRER
      INSERT INTO public.notifications (user_id, type, message, link)
      VALUES (v_referrer_id, 'referral_earning', 'You earned a $' || v_commission_amount::text || ' commission!', 'referralProgram');
    END IF;
  END IF;
  
END;
$$;

-- ========= NOTIFICATIONS =========
-- 18. Create Notifications table
CREATE TABLE public.notifications (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    type TEXT NOT NULL,
    message TEXT NOT NULL,
    is_read BOOLEAN DEFAULT false NOT NULL,
    link TEXT -- Optional URL for navigation within the app
);
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own notifications" ON public.notifications
    FOR ALL USING (auth.uid() = user_id);

-- ========= CHART ANNOTATIONS =========
-- 19. Create user_chart_annotations table
CREATE TABLE public.user_chart_annotations (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    asset_ticker TEXT NOT NULL,
    annotations TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(user_id, asset_ticker)
);
ALTER TABLE public.user_chart_annotations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own chart annotations" ON public.user_chart_annotations
    FOR ALL USING (auth.uid() = user_id);

-- 20. Create a trigger to automatically update the updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = timezone('utc'::text, now());
   RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_user_chart_annotations_updated_at
BEFORE UPDATE ON public.user_chart_annotations
FOR EACH ROW
EXECUTE PROCEDURE public.update_updated_at_column();

-- ========= CHART DRAWINGS =========
-- 21. Create user_chart_drawings table
CREATE TABLE public.user_chart_drawings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    asset_ticker TEXT NOT NULL,
    drawings_json JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    UNIQUE(user_id, asset_ticker)
);
ALTER TABLE public.user_chart_drawings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own chart drawings" ON public.user_chart_drawings
    FOR ALL USING (auth.uid() = user_id);

-- 22. Add trigger for updated_at on the new table
CREATE TRIGGER update_user_chart_drawings_updated_at
BEFORE UPDATE ON public.user_chart_drawings
FOR EACH ROW
EXECUTE PROCEDURE public.update_updated_at_column();


-- ========= INDICATOR SETTINGS =========
-- 23. Create user_indicator_settings table
CREATE TABLE public.user_indicator_settings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
    settings_json JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE public.user_indicator_settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can manage their own indicator settings" ON public.user_indicator_settings
    FOR ALL USING (auth.uid() = user_id);

-- 24. Add trigger for updated_at on the new table
CREATE TRIGGER update_user_indicator_settings_updated_at
BEFORE UPDATE ON public.user_indicator_settings
FOR EACH ROW
EXECUTE PROCEDURE public.update_updated_at_column();